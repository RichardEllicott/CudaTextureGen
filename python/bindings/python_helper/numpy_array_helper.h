/*

numpy helper functions with new templates

⚠️ generated by copilot asking it to convert my old ones to templates be careful for now!

*/
#pragma once

#include "core.h"
#include <cstring> // required for std::memcpy in linux (not windows)
#include <nanobind/nanobind.h>
#include <nanobind/ndarray.h>
#include <vector>

// helpers to make python objects which is a bit convoluted from python
namespace python_helper {

namespace nb = nanobind; // shortcut

#pragma region TYPE_MAPPING

// Type-to-dtype mapping
template <typename T>
struct numpy_dtype; // no default

template <>
struct numpy_dtype<float> {
    static constexpr auto value = "float32";
};
template <>
struct numpy_dtype<double> {
    static constexpr auto value = "float64";
};
template <>
struct numpy_dtype<int> {
    static constexpr auto value = "int32";
};
template <>
struct numpy_dtype<long long> {
    static constexpr auto value = "int64";
};
template <>
struct numpy_dtype<uint8_t> {
    static constexpr auto value = "uint8";
};
template <>
struct numpy_dtype<bool> {
    static constexpr auto value = "bool_";
};
// …extend as needed

#pragma endregion

#pragma region CREATE_EMPTY

// Generic factory
template <typename T>
inline nb::ndarray<nb::numpy, T> get_numpy_array(int height, int width) {
    nb::module_ np = nb::module_::import_("numpy");
    nb::object arr_obj = np.attr("empty")(
        nb::make_tuple(height, width),
        numpy_dtype<T>::value);
    return nb::cast<nb::ndarray<nb::numpy, T>>(arr_obj);
}

// Generic factory
template <typename T>
inline nb::ndarray<nb::numpy, T> get_numpy_array(int height, int width, int depth) {
    nb::module_ np = nb::module_::import_("numpy");
    nb::object arr_obj = np.attr("empty")(
        nb::make_tuple(height, width, depth),
        numpy_dtype<T>::value);
    return nb::cast<nb::ndarray<nb::numpy, T>>(arr_obj);
}

#pragma endregion

#pragma region VECTOR

// Convert ndarray -> std::vector<T>
template <typename T>
inline std::vector<T> numpy_array_to_vector(nb::ndarray<T, nb::c_contig> arr) {
    if (arr.ndim() != 2)
        throw std::runtime_error("Input must be a 2D array");

    size_t size = arr.shape(0) * arr.shape(1);
    std::vector<T> result(size);
    std::memcpy(result.data(), arr.data(), size * sizeof(T));
    return result;
}

// Convert std::vector<T> -> ndarray<T>
template <typename T>
inline nb::ndarray<nb::numpy, T> vector_to_numpy_array(const std::vector<T> &source,
                                                       int height, int width) {

    size_t size = static_cast<size_t>(height) * static_cast<size_t>(width);
    if (source.size() != size)
        throw std::runtime_error("Source vector size doesn't match requested dimensions");

    auto arr = get_numpy_array<T>(height, width); // uses the dtype traits

    std::memcpy(arr.data(), source.data(), size * sizeof(T));
    return arr;
}

#pragma endregion

#pragma region ARRAY2D

// ndarray<T> -> core::Array2D<T>
template <typename T>
inline core::Array2D<T> numpy_array_to_array2d(nb::ndarray<T, nb::c_contig> arr) {
    if (arr.ndim() != 2)
        throw std::runtime_error("Input must be a 2D array");

    size_t height = arr.shape(0);
    size_t width = arr.shape(1);

    core::Array2D<T> result(width, height);
    std::memcpy(result.data(), arr.data(), width * height * sizeof(T));
    return result;
}

// core::Array2D<T> -> ndarray<T>
template <typename T>
inline nb::ndarray<nb::numpy, T> array2d_to_numpy_array(const core::Array2D<T> &source) {
    size_t width = source.get_width();
    size_t height = source.get_height();
    size_t size = width * height;

    auto arr = get_numpy_array<T>(height, width); // uses dtype traits

    std::memcpy(arr.data(), source.data(), size * sizeof(T));
    return arr;
}

#pragma endregion

} // namespace python_helper