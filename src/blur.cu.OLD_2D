/*

gaussian blur, uses a 2D kernel (may be slow)

*/
#include "core_api.h"
#include <cuda_runtime.h>

void buildGaussianKernel(float *kernel, int kSize, float sigma)
{
    float sum = 0.0f;
    int radius = kSize / 2;
    for (int y = -radius; y <= radius; ++y)
    {
        for (int x = -radius; x <= radius; ++x)
        {
            float value = expf(-(x * x + y * y) / (2 * sigma * sigma));
            kernel[(y + radius) * kSize + (x + radius)] = value;
            sum += value;
        }
    }
    // Normalize
    for (int i = 0; i < kSize * kSize; ++i)
    {
        kernel[i] /= sum;
    }
}

__global__ void gaussianBlurKernel(const float *input, float *output, int width, int height, const float *kernel, int kSize, bool wrap)
{
    int x = blockIdx.x * blockDim.x + threadIdx.x;
    int y = blockIdx.y * blockDim.y + threadIdx.y;
    if (x >= width || y >= height)
        return;

    float sum = 0.0f;
    int radius = kSize / 2;
    for (int ky = -radius; ky <= radius; ++ky)
    {
        for (int kx = -radius; kx <= radius; ++kx)
        {

            int ix = x + kx;
            int iy = y + ky;

            if (wrap)
            {
                ix = (ix + width) % width;
                iy = (iy + height) % height;
            }
            else
            {
                ix = min(max(ix, 0), width - 1);
                iy = min(max(iy, 0), height - 1);
            }

            float pixel = input[iy * width + ix];
            float weight = kernel[(ky + radius) * kSize + (kx + radius)];
            sum += pixel * weight;
        }
    }
    output[y * width + x] = sum;
}

void run_blur(float *host_data, int width, int height, float sigma, bool wrap)
{
    int imageSize = width * height * sizeof(float);

    int kSize = static_cast<int>(std::ceil(6 * sigma)) | 1; // Ensure odd size
    // int kSize = std::min(static_cast<int>(std::ceil(6 * sigma)) | 1, 31); //Ensure odd size, cap at 31x31

    // Allocate and build kernel
    float *h_kernel = new float[kSize * kSize];
    buildGaussianKernel(h_kernel, kSize, sigma);

    // Allocate device memory
    float *d_input, *d_output, *d_kernel;
    cudaMalloc(&d_input, imageSize);
    cudaMalloc(&d_output, imageSize);
    cudaMalloc(&d_kernel, kSize * kSize * sizeof(float));

    // Copy data
    cudaMemcpy(d_input, host_data, imageSize, cudaMemcpyHostToDevice);
    cudaMemcpy(d_kernel, h_kernel, kSize * kSize * sizeof(float), cudaMemcpyHostToDevice);

    // Launch kernel
    dim3 block(16, 16);
    dim3 grid((width + block.x - 1) / block.x, (height + block.y - 1) / block.y);
    gaussianBlurKernel<<<grid, block>>>(d_input, d_output, width, height, d_kernel, kSize, wrap);

    // Copy result back
    cudaMemcpy(host_data, d_output, imageSize, cudaMemcpyDeviceToHost);

    // Cleanup
    cudaFree(d_input);
    cudaFree(d_output);
    cudaFree(d_kernel);
    delete[] h_kernel;
}